/**
 * @file spiceexporter.cpp
 * @brief SPICE netlist exporter implementation
 */

#include "spiceexporter.h"
#include <QFile>
#include <QTextStream>
#include <cmath>

namespace SmithTool {

SpiceExporter::SpiceExporter()
    : m_format(SpiceFormat::Standard)
    , m_analysisType(AnalysisType::AC)
    , m_frequency(1e9)
    , m_z0(50.0)
    , m_sourceZ(50.0, 0.0)
    , m_loadZ(50.0, 0.0)
    , m_title("SmithTool Matching Network")
    , m_startFreq(100e6)
    , m_stopFreq(10e9)
    , m_numPoints(101)
{
}

void SpiceExporter::setFrequencyRange(double startFreq, double stopFreq, int numPoints)
{
    m_startFreq = startFreq;
    m_stopFreq = stopFreq;
    m_numPoints = numPoints;
}

QString SpiceExporter::generateNetlist(const MatchingTrace& trace) const
{
    QString netlist;
    QTextStream out(&netlist);
    
    // Header
    out << formatHeader();
    out << "\n";
    
    // Comments
    out << "* Source Impedance: " << m_sourceZ.real() << " + j" << m_sourceZ.imag() << " Ohm\n";
    out << "* Load Impedance: " << m_loadZ.real() << " + j" << m_loadZ.imag() << " Ohm\n";
    out << "* Center Frequency: " << engineeringNotation(m_frequency) << "Hz\n";
    out << "\n";
    
    // Node numbering: 0 = GND, 1 = input, N = output (load)
    int currentNode = 1;
    
    // Source impedance (if not pure 50 ohm)
    out << formatSourceImpedance(currentNode);
    
    // Matching network elements
    const auto& segments = trace.segments();
    for (size_t i = 0; i < segments.size(); ++i) {
        out << formatElement(segments[i], static_cast<int>(i), currentNode);
    }
    
    // Load impedance
    out << formatLoadImpedance(currentNode);
    out << "\n";
    
    // Analysis commands
    out << formatAnalysis();
    out << "\n";
    
    // Ending
    out << formatEnding();
    
    return netlist;
}

bool SpiceExporter::exportToFile(const QString& filename, const MatchingTrace& trace) const
{
    QFile file(filename);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        return false;
    }
    
    QTextStream out(&file);
    out << generateNetlist(trace);
    file.close();
    
    return true;
}

QString SpiceExporter::generateSubcircuit(const MatchingTrace& trace, const QString& name) const
{
    QString subckt;
    QTextStream out(&subckt);
    
    // Subcircuit header
    out << ".SUBCKT " << name << " IN OUT\n";
    out << "* Matching Network Subcircuit\n";
    out << "* Generated by SmithTool\n\n";
    
    int currentNode = 1;  // Start at node 1 (IN is external)
    
    // Elements
    const auto& segments = trace.segments();
    for (size_t i = 0; i < segments.size(); ++i) {
        const TraceSegment& seg = segments[i];
        int startNode = (i == 0) ? 1 : currentNode;  // First element connects to IN (node 1)
        int nextNode = currentNode + 1;
        
        QString elemName;
        double value = seg.componentValue;
        
        if (seg.connectionType == ConnectionType::Series) {
            // Series element: connects startNode to nextNode
            switch (seg.componentType) {
                case ComponentType::Resistor:
                    elemName = QString("RS%1").arg(i + 1);
                    out << formatResistor(elemName, startNode, nextNode, value);
                    break;
                case ComponentType::Inductor:
                    elemName = QString("LS%1").arg(i + 1);
                    out << formatInductor(elemName, startNode, nextNode, value);
                    break;
                case ComponentType::Capacitor:
                    elemName = QString("CS%1").arg(i + 1);
                    out << formatCapacitor(elemName, startNode, nextNode, value);
                    break;
                default:
                    break;
            }
            currentNode = nextNode;
        } else {
            // Shunt element: connects currentNode to GND
            switch (seg.componentType) {
                case ComponentType::Resistor:
                    elemName = QString("RP%1").arg(i + 1);
                    out << formatResistor(elemName, currentNode, 0, value);
                    break;
                case ComponentType::Inductor:
                    elemName = QString("LP%1").arg(i + 1);
                    out << formatInductor(elemName, currentNode, 0, value);
                    break;
                case ComponentType::Capacitor:
                    elemName = QString("CP%1").arg(i + 1);
                    out << formatCapacitor(elemName, currentNode, 0, value);
                    break;
                default:
                    break;
            }
        }
    }
    
    // Connect last node to OUT
    out << QString("ROUT %1 OUT 0\n").arg(currentNode);  // Zero resistance connection
    
    out << ".ENDS " << name << "\n";
    
    return subckt;
}

QString SpiceExporter::formatHeader() const
{
    QString header;
    
    switch (m_format) {
        case SpiceFormat::LTspice:
            header = QString("* %1\n").arg(m_title);
            header += "* Generated by SmithTool for LTspice\n";
            break;
        case SpiceFormat::Ngspice:
            header = QString(".title %1\n").arg(m_title);
            header += "* Generated by SmithTool for Ngspice\n";
            break;
        case SpiceFormat::QucsS:
            header = QString("# %1\n").arg(m_title);
            header += "# Generated by SmithTool for Qucs-S\n";
            break;
        default:
            header = QString("* %1\n").arg(m_title);
            header += "* Generated by SmithTool\n";
            break;
    }
    
    return header;
}

QString SpiceExporter::formatSourceImpedance(int& nodeNum) const
{
    QString source;
    QTextStream out(&source);
    
    // AC voltage source
    out << "* AC Source with impedance\n";
    out << "V1 " << nodeNum << " 0 AC 1\n";  // 1V AC source
    
    // Source resistance (real part)
    if (std::abs(m_sourceZ.real()) > 1e-9) {
        out << formatResistor("RS", nodeNum, nodeNum + 1, m_sourceZ.real());
        nodeNum++;
    }
    
    // Source reactance (imaginary part)
    if (std::abs(m_sourceZ.imag()) > 1e-9) {
        double X = m_sourceZ.imag();
        if (X > 0) {
            // Inductive
            double L = X / (2.0 * M_PI * m_frequency);
            out << formatInductor("LS", nodeNum, nodeNum + 1, L);
        } else {
            // Capacitive
            double C = -1.0 / (2.0 * M_PI * m_frequency * X);
            out << formatCapacitor("CS", nodeNum, nodeNum + 1, C);
        }
        nodeNum++;
    }
    
    out << "\n";
    return source;
}

QString SpiceExporter::formatLoadImpedance(int nodeNum) const
{
    QString load;
    QTextStream out(&load);
    
    out << "* Load Impedance\n";
    
    int loadNode = nodeNum;
    
    // Load resistance (real part)
    if (std::abs(m_loadZ.real()) > 1e-9) {
        out << formatResistor("RL", loadNode, 0, m_loadZ.real());
    }
    
    // Load reactance (imaginary part)
    if (std::abs(m_loadZ.imag()) > 1e-9) {
        double X = m_loadZ.imag();
        if (X > 0) {
            // Inductive (series with load R)
            double L = X / (2.0 * M_PI * m_frequency);
            out << formatInductor("LL", loadNode, 0, L);
        } else {
            // Capacitive
            double C = -1.0 / (2.0 * M_PI * m_frequency * X);
            out << formatCapacitor("CL", loadNode, 0, C);
        }
    }
    
    return load;
}

QString SpiceExporter::formatElement(const TraceSegment& seg, int index, int& nodeNum) const
{
    QString elem;
    QTextStream out(&elem);
    
    double value = seg.componentValue;
    QString suffix = QString::number(index + 1);
    
    if (seg.connectionType == ConnectionType::Series) {
        // Series element connects nodeNum to nodeNum+1
        int nextNode = nodeNum + 1;
        
        switch (seg.componentType) {
            case ComponentType::Resistor:
                out << formatResistor("R" + suffix, nodeNum, nextNode, value);
                break;
            case ComponentType::Inductor:
                out << formatInductor("L" + suffix, nodeNum, nextNode, value);
                break;
            case ComponentType::Capacitor:
                out << formatCapacitor("C" + suffix, nodeNum, nextNode, value);
                break;
            default:
                break;
        }
        
        nodeNum = nextNode;
    } else {
        // Shunt element connects nodeNum to GND (node 0)
        switch (seg.componentType) {
            case ComponentType::Resistor:
                out << formatResistor("R" + suffix, nodeNum, 0, value);
                break;
            case ComponentType::Inductor:
                out << formatInductor("L" + suffix, nodeNum, 0, value);
                break;
            case ComponentType::Capacitor:
                out << formatCapacitor("C" + suffix, nodeNum, 0, value);
                break;
            default:
                break;
        }
    }
    
    return elem;
}

QString SpiceExporter::formatAnalysis() const
{
    QString analysis;
    QTextStream out(&analysis);
    
    out << "* Analysis Commands\n";
    
    switch (m_analysisType) {
        case AnalysisType::AC:
            out << QString(".AC DEC %1 %2 %3\n")
                   .arg(m_numPoints)
                   .arg(engineeringNotation(m_startFreq))
                   .arg(engineeringNotation(m_stopFreq));
            break;
        case AnalysisType::SP:
            if (m_format == SpiceFormat::Ngspice || m_format == SpiceFormat::QucsS) {
                out << QString(".SP LIN %1 %2 %3\n")
                       .arg(m_numPoints)
                       .arg(engineeringNotation(m_startFreq))
                       .arg(engineeringNotation(m_stopFreq));
            } else {
                // Fallback to AC for simulators without S-param
                out << QString(".AC DEC %1 %2 %3\n")
                       .arg(m_numPoints)
                       .arg(engineeringNotation(m_startFreq))
                       .arg(engineeringNotation(m_stopFreq));
            }
            break;
        case AnalysisType::Transient:
            {
                double period = 1.0 / m_frequency;
                double stopTime = 10.0 * period;
                double step = period / 100.0;
                out << QString(".TRAN %1 %2\n")
                       .arg(engineeringNotation(step))
                       .arg(engineeringNotation(stopTime));
            }
            break;
    }
    
    // Print/plot commands
    if (m_format == SpiceFormat::LTspice) {
        out << ".PROBE\n";
    } else if (m_format == SpiceFormat::Ngspice) {
        out << ".CONTROL\n";
        out << "run\n";
        out << "plot vdb(out)\n";
        out << ".ENDC\n";
    }
    
    return analysis;
}

QString SpiceExporter::formatEnding() const
{
    if (m_format == SpiceFormat::QucsS) {
        return "";
    }
    return ".END\n";
}

QString SpiceExporter::formatResistor(const QString& name, int node1, int node2, double value) const
{
    return QString("%1 %2 %3 %4\n")
           .arg(name)
           .arg(node1)
           .arg(node2)
           .arg(formatValue(value, ""));
}

QString SpiceExporter::formatCapacitor(const QString& name, int node1, int node2, double value) const
{
    return QString("%1 %2 %3 %4\n")
           .arg(name)
           .arg(node1)
           .arg(node2)
           .arg(formatValue(value, ""));
}

QString SpiceExporter::formatInductor(const QString& name, int node1, int node2, double value) const
{
    return QString("%1 %2 %3 %4\n")
           .arg(name)
           .arg(node1)
           .arg(node2)
           .arg(formatValue(value, ""));
}

QString SpiceExporter::formatValue(double value, const QString& unit) const
{
    Q_UNUSED(unit);
    return engineeringNotation(value);
}

QString SpiceExporter::engineeringNotation(double value) const
{
    if (value == 0) return "0";
    
    // Define SI prefixes
    const char* prefixes[] = {"f", "p", "n", "u", "m", "", "k", "Meg", "G", "T"};
    const int prefixOffset = 5;  // Index of "" (no prefix)
    
    double absValue = std::abs(value);
    int exp = static_cast<int>(std::floor(std::log10(absValue)));
    int prefixIndex = prefixOffset + (exp / 3);
    
    // Clamp to valid range
    if (prefixIndex < 0) prefixIndex = 0;
    if (prefixIndex > 9) prefixIndex = 9;
    
    // Calculate the scaled value
    double scale = std::pow(10.0, (prefixIndex - prefixOffset) * 3);
    double scaledValue = value / scale;
    
    // Format with appropriate precision
    QString result;
    if (std::abs(scaledValue) >= 100) {
        result = QString::number(scaledValue, 'f', 1);
    } else if (std::abs(scaledValue) >= 10) {
        result = QString::number(scaledValue, 'f', 2);
    } else {
        result = QString::number(scaledValue, 'f', 3);
    }
    
    return result + prefixes[prefixIndex];
}

} // namespace SmithTool
